\documentclass[11pt, a4paper, BCOR=10mm, ngerman, oneside]{scrbook}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{hyperref} 
\usepackage{amsmath}
\usepackage[parfill]{parskip}
\usepackage{listings}
\usepackage{float}
\usepackage{slashbox}
\usepackage{pgfgantt}
\usepackage{wrapfig}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{color}
\usepackage{pdflscape}
\usepackage{array}
\usepackage{caption}
\usepackage{tkz-euclide}
\usepackage{pgfplots} 



\usepackage{tikz}
\usetikzlibrary{positioning,shapes.geometric, arrows,automata, decorations.pathreplacing}
\usepackage{pgf}

\usepackage[english]{babel}
\hypersetup{
    bookmarks=true,
    unicode=false,
    pdftoolbar=true,
    pdfmenubar=true,
    pdffitwindow=false,
    pdfstartview={FitH},
    pdftitle={Property Directed Reachability in Ultimate},
    pdfauthor={Author},
    pdfsubject={Subject},
    pdfcreator={Creator},
    pdfproducer={Producer},
    pdfkeywords={keyword1} {key2} {key3},
    pdfnewwindow=true,
    colorlinks=false,
    linkcolor=red,
    citecolor=green,
    filecolor=magenta,
    urlcolor=cyan
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\makeatletter
\newcommand{\thickhline}{%
    \noalign {\ifnum 0=`}\fi \hrule height 1pt
    \futurelet \reserved@a \@xhline
}
\newcolumntype{"}{@{\hskip\tabcolsep\vrule width 1pt\hskip\tabcolsep}}
\makeatother

\newcolumntype{?}{!{\vrule width 2pt}}


\begin{document}

\begin{titlepage}
\begin{center}

\newcommand{\HorizontalLine}{\rule{\linewidth}{0.3mm}}

	{\scshape\Large Bachelor Thesis\par}


% _____________________________________________________________________________
\HorizontalLine \\[0.4cm]
	{\huge\scshape Property Directed Reachability \\ \Large{In Ultimate} \par}
\HorizontalLine \\[1.5cm]
% _____________________________________________________________________________


	{\Large \scshape Jonas Werner}\\[5cm]


\begin{tabular}[scshape]{>{\normalsize}l >{\normalsize}l}
  \scshape Examiner: & \scshape Prof. Dr. \\[0.3cm]
  \scshape Adviser: & \scshape Dr. Daniel Dietsch  \\[1.2cm]
\end{tabular}
\vfill  % move the following text to the bottom

\large { \scshape
    Albert-Ludwigs-University Freiburg\\
    Faculty of Engineering\\
    Department of Computer Science\\
    Chair of Software Engineering \\[1cm]

    August 3\textsuperscript{rd}, 2018\\
}
\end{center}
\end{titlepage}

    \pagestyle{plain} % remove chapter name from top, page number at the bottom
    \frontmatter  % roman page numbers

% title page back
\ \vfill \ \\  % at least one space required before vfill
\
\textbf{Writing period}            \smallskip{} \\
03.\,05.\,2018 -- 03.\,08.\,2018   \bigskip{} \\
\
\textbf{Examiner}                  \smallskip{} \\
Prof. Dr. \bigskip{} \\
\
\textbf{Adviser}                  \smallskip{} \\
Dr. Daniel Dietsch

\pagebreak

\chapter*{Declaration}

I hereby declare, that I am the sole author and composer of my thesis and that no other sources or learning aids, other than those listed, have been used. Furthermore, I declare that I have acknowledged the work of others by providing detailed references of said work.  \newline
I hereby also declare, that my Thesis has not been prepared for another examination
or assignment, either wholly or excerpts thereof.
\\[3\normalbaselineskip]
\begin{tabular}{p{0.5\textwidth} l}
  \rule{0.33\textwidth}{0.4pt}   &   \rule{0.33\textwidth}{0.4pt} \\
  Place, Date                  &   Jonas Werner
\end{tabular}

\chapter*{Abstract}
foo bar

\chapter*{Zusammenfassung}
foo bar aber auf deutsch



\tableofcontents


\mainmatter

\chapter{Introduction}
SAT-based model-checking is a useful technique for both software and hardware verification. Most modern model-checkers are based on interpolation \cite{Zitat00}. 
Recently a novel hardware verification algorithm was devised by Aaron Bradley \cite{Zitat01} called \texttt{IC3}.
Because it was so new, it came as a surprise that it won third place in the hardware
model-checking competition (HWMCC) at CAV 2010 \cite{cav}. \\ The model-checking method behind \texttt{IC3} is called \textsl{Property Directed Reachability}, \textsl{PDR} for short, which is not based on interpolation but on backward-search. It tries to find inductive invariants by constructing an over-approximation of reachable states. During this construction, possible counter-examples are disproved using Boolean SAT queries. Because this approach turned out to be very efficient for hardware verification, it could be interesting for software verification as well. \\ \par
\textsc{Ultimate} \cite{Zitat02} is a software analysis framework consisting of multiple plugins that perform steps of a program analysis, like parsing source code, trans-
forming programs from one representation to another, or analyse programs.
 \textsc{Ultimate} already has analysis-plugins using different model-checking techniques like trace abstraction \cite{Zitat06} or lazy interpolation \cite{Zitat07}.
The goal of this Bachelor's Thesis is to implement a new analysis-plugin that uses PDR on software in \textsc{Ultimate} and to compare it with the other existing techniques.


\chapter{Related Work}
\textbf{How much Detail?} \\
Because hardware verification is limited to propositional logic, we need techniques to lift PDR from bit level to first-order logic formulas used in software, for that there are three other approaches: \par

The first approach of using PDR on software is rather naive, Welp et al propose in \cite{Welp} a way to encode variables as bitvectors and then using the unmodified PDR on that encoding. 

The first ever approach of using PDR on first-order formulas came in 2012 by Cimatti and Griggio in \cite{Zitat04} who proposed exploiting the partitioning of a program's state space by unwinding the program's control flow graph into an Abstract Reachability Tree where each node is coupled with a location and a first-order formula, resulting in a so called explicit-symbolic approach. Possible counterexample traces are disproved by computing under-approximations of predecessors. 

Another possible way is proposed by Hoder and BjÃ¸rner in \cite{GeneralizedIc3} operating on an abstract transition system derived from the program. A non-linear variant of PDR is used, so that counterexamples unfold into trees that can be recursively generalized until either proven or disproved.







\chapter{PDR Background}
\label{PDR}
In the following we will describe how IC3 and to that extend PDR works as a hardware-checker, because hardware only uses bits, every variable will be boolean.
\section{Preliminaries}
First some preliminary definitions and notations:  \par
A \textsl{literal} is a variable or its negation, e.g., $x \text{ or } \bar y$ \\
A \textsl{clause} is a disjunction of literals, e.g., $x \lor \bar y$ \\
A \textsl{cube} is a conjunction of literals, e.g.,  $x \land \bar y$ \\
Therefore, the negation of a cube is a clause. $\overline{(x \land \bar y)} \equiv (\bar x \lor y)$  \par
A \textsl{boolean transition system} is a tuple $S = (X, I, T)$, where $X$ is a finite set of boolean variables, $I$ is a cube representing the \textsl{initial state}, and $T$ is a propositional formula over variables in $X$ and $X' = \{x \in X \ | \ x' \in X'\}$, called transition relation, that describes updates to the variables.
\par
For example, consider the transition system $U = (X, I, T)$ where
\begin{itemize}
\item $ X= \{x_1, x_2, x_3\}$
\item $I = \bar x_1 \land \bar x_2 \land \bar x_3$
\item $T = (x_1 \lor \neg x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')$
\end{itemize}
\pagebreak
With corresponding transition graph:

\begin{figure}[H]
\hspace*{-2.5cm}
\begin{tikzpicture}[%
    ->,
    >=stealth', shorten >=1pt, auto,
    node distance=9cm, scale=1, 
    transform shape, align=center,    
    state/.style={%
      circle,
      minimum size=3.5cm,
      scale=0.7,
      draw
    }
  ]
    \node[initial, state](1){$\bar x_1 \land \bar x_2 \land \bar x_3$};
    
    \node[state] (2) [above right of=1] {$ x_1 \land \bar x_2 \land \bar x_3$};
    
    \node[state] (3) [below right of=1] {$ \bar x_1 \land \bar x_2 \land \bar x_3$};
    
    \node[state, node distance=6.3639610306789275cm] (4) [right of=2] {$ x_1 \land x_2 \land \bar x_3$};
    
    \node[state, node distance=6.3639610306789275cm] (5) [right of=3] {$ \bar x_1 \land x_2 \land x_3$};
    
    \node[state] (6) [below right of=4] {$ x_1 \land x_2 \land x_3$};
    
    \node[state, node distance=6.3639610306789275cm] (7) [below of=2] {$\bar x_1 \land x_2 \land \bar x_3$};
    
    \node[state, node distance=6.3639610306789275cm] (8) [below of=4] {$x_1 \land \bar x_2 \land x_3$};
    

 	  \path (1) edge node {} (2)
 	  		(1) edge [loop above] node {} (1)
 	  
 	  		(2) edge node {} (4)
 	  		(2) edge node {} (7)
 	  		
			(3) edge node {} (1)
 	  		(3) edge [bend left] node {} (2) 	  		
 	  		
 	  		(4) edge node {} (6)
 	  		(4) edge [bend left] node {} (5)
 	  		
 	  		(5) edge node {} (3)
 	  		(5) edge node {} (8)
 	  		
 	  		(6) edge node {} (5)
 	  		(6) edge [loop above] node {} (6)
 	  		
 	  		(7) edge node {} (3)
 	  		(7) edge [bend left] node {} (8)
 	  		
 	  		(8) edge node {} (4)
 	  		(8) edge [bend left] node {} (7)
 	  ;

    
);
  \end{tikzpicture}
  \caption{Transition Graph of $U$}
 \end{figure}
 \label{ex1}  

 

Given a propositional formula $\phi$ over $X$ we get a \textsl{primed formula} $\phi'$ by replacing each variable with its corresponding variable in $X'$. \par

A \textsl{state} in $S$ is a cube containing each variable from $X$ with a boolean valuation of it. For each possible valuation there is a corresponding state, resulting in $2^{|X|}$ states in $S$. \\
Like we see in the graph of $U$ we have $2^{|X|} = 2^3 = 8$ states.

A \textsl{transition} from one state $s$ to another state $q$ exists if the conjunction of $s$, the transition relation, and $q'$ is satisfiable.\\ For example in $U$ the transition between the initial state $I = \bar x_1 \land \bar x_2 \land \bar x_3$ and state $r = x_1 \land \bar x_2 \land \bar x_3$ exists because
\begin{equation*}
\underbrace{\bar x_1 \land \bar x_2 \land \bar x_3}_{I} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_T \land \underbrace{x_1' \land \bar x_2' \land \bar x_3'}_{r'}
\end{equation*}
is satisfiable.\par

Given a propositional formula $P$ over $X$, called \textsl{property}, we want
to verify that every state in $S$ that is reachable from
$I$ satisfies $P$ such that, $P$ describes a finite set of \textsl{good states}, conversely $\bar P$ represent a finite set of $bad$ states.  \\ 
Regarding $U$, let $P = \bar x_1 \lor \bar x_2 \lor \bar x_3$ be given, making $\bar P = x_1 \land x_2 \land x_3$ a bad state. \\ 
We can use PDR to show that either $\bar P$ is unreachable from $I$ or that there exists a sequence of transitions leading to $\bar P$ as counter-example.

\section{Algorithm}
A PDR-based algorithm tries to prove that a transition system $S = (X, I, T)$ satisfies a given property $P$ by trying to find a formula $F$ over $X$ with the following qualities:
\begin{itemize}
\item[(1)] $I \Rightarrow F$
\item[(2)] $F \land T \Rightarrow F'$
\item[(3)] $F \Rightarrow P$
\end{itemize}
$F$ is called an \textsl{inductive invariant}. \\ 
To calculate an inductive invariant, PDR uses \textsl{frames} which are cubes of clauses representing an over-approximation of reachable states in at most $i$ transitions from $I$. \\
PDR maintains a sequence of frames [$F_0, ..., F_k$], called a \textsl{trace}, it is organized so that it fulfills the following characteristics: 

\begin{itemize}
\item[(I)] $F_0 = I$
\item[(II)] $F_{i+1} \subseteq F_{i}$, therefore $F_i \Rightarrow F_{i+1}$
\item[(III)] $F_i \land T \Rightarrow F_{i+1}'$
\item[(IV)] $F_i \Rightarrow P$
\end{itemize}

Now to the algorithm itself: \\
Start with checking for a \textsl{0-counter-example}, that means checking if $I \Rightarrow P$, by testing whether the formula $I \land \bar P$ is satisfiable. If it is, then $I$ is a 0-counter-example, the algorithm terminates.
If the formula is unsatisfiable, initialize the first frame $F_0 = I$, fulfilling (I), and moving on. \\

Let $[F_0, F_1, ..., F_k]$ be the current trace. \\ 
The algorithm repeats the following three phases until termination: \par

\textsl{1. Next Transition} \\ Check whether the next state is a good state meaning $F_k \land T \Rightarrow P'$ is valid, by testing the satisfiability of $F_k \land T \land \bar P'$ 
\begin{itemize}
\item If the formula is \textsl{satisfiable}, for each satisfying assignment \\ $\vec{x} = (x_1, x_2, ..., x_{|X|}, x_1', x_2', ..., x'_{|X'|})$ get a new bad state \\ $a = x_1 \land x_2 \land ... \land x_{|X|}$ and create tuple $(a, k)$, this tuple is called a \textsl{proof-obligation}.

\item If the formula is \textsl{unsatisfiable}, continue with the next phase. \\

\end{itemize}


\textsl{2. Blocking-Phase} \\If there are proof-obligations: \\ 
Take proof-obligation $(b, i)$ and try to block the bad state $b$ by checking if frame $F_{i-1}$ can reach $b$ in one transition, i.e., test $F_{i-1} \land T \land b'$ for satisfiability.

\begin{itemize}
\item If the formula is \textsl{satisfiable}, it means that $F_{i}$ is not strong enough to block $b$. For each satisfying assignment \\ $\vec{x} = (x_1, x_2, ..., x_{|X|}, x_1', x_2', ..., x'_{|X'|})$ get a new bad state \\ $c = x_1 \land x_2 \land ... \land x_{|X|}$ creating the new proof-obligation $(c, i-1)$.

\item If the formula is \textsl{unsatisfiable}, strengthen frame $F_{i}$ with $\bar b$ meaning $F_i = F_i \land \bar b$, blocking $b$ at $F_{i}$ 

\end{itemize}

This continues recursively until either a proof-obligation $(d, 0)$ is created proving that there exists a counter-example terminating the algorithm, or
there is no proof-obligation left. \\

\textsl{3. Propagation-Phase}\\ Add a new frame $F_{k + 1} = P$ and propagate clauses from $F_{k}$ forward, meaning for all clauses $c$ in $F_{k}$ check $F_{k} \land T \land \bar c'$ for satisfiability. If that conjunction is unsatisfiable, strengthen $F_{k+1}$ with $c$: $F_{k+1} = F_{k+1} \land c$, else do nothing and continue with the next clause. Because of this phase rule (II) is fulfilled.\\ \\
After propagating all possible clauses, if $F_{k+1} \equiv F_{k}$ the algorithm found a fixpoint and terminates returning that $P$ always holds with $F_k$ being the inductive invariant. \\ \\

\pagebreak

To illustrate the procedure further consider the pseudo-code: \\

\begin{algorithm}[H] 
\caption{PDR-prove}
\begin{algorithmic}[1]
\Procedure{PDR-prove}{$I, T, P$}
\State check for 0-counter-example
\State $trace.push(new\ frame(I))$
\Statex
\Loop

	\While {$\exists$ cube c, s.t. $trace.last() \land T \land c'$ is SAT and $c \Rightarrow \bar P$}
	\State recursively block proof-obligation(c, trace.size() - 1)
	\State and strengthen the frames of the trace.
	\If {a proof-obligation(p, 0) is generated}
	
	\State{\Return{false}} \Comment{counter-example found}
	\EndIf
	\EndWhile

	\Statex	
	
	\State $F_{k+1} = new\ frame(P)$
		\ForAll{clause c $\in$ $trace.last()$}
		\If{$trace.last() \land T \land \bar c'$ is UNSAT} 
		\State{$F_{k+1} = F_{k+1} \land c$}
	\EndIf
\EndFor
	\If {$trace.last() == F_{k+1}$}
	\State{\Return{true}}
	\EndIf
	\State $trace.push(F_{k+1})$

\EndLoop
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Examples}
 
\subsection{With Failing Property} 
To show an application of the algorithm reconsider the \hyperref[ex1]{example} transition system $U = (X, I, T$) where \par
\begin{itemize}
\item $X = \{x_1, x_2, x_3\}$
\item $I = \bar x_1 \land \bar x_2 \land \bar x_3$
\item $T = (x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')$
\end{itemize}
and the property: 
\begin{itemize}
\item $P = \bar x_1 \lor \bar x_2 \lor \bar x_3$ with bad state $\bar P = x_1 \land x_2 \land x_3$ 
\end{itemize}
We now want to verify whether $P$ holds or if there is a counter-example. \\ \\

\textbf{1. Step: Check for 0-Counter-Example} \\ We need to make sure that $ I \Rightarrow P$, we do that by testing if $I \land \bar P$ is satisfiable:
\begin{equation*}
\underbrace{\bar x_1 \land \bar x_2 \land \bar x_3}_{\text{I}} \land \underbrace{x_1 \land x_2 \land x_3}_{ \bar P}
\end{equation*}
The formula is unsatisfiable meaning there is no 0-counter-example, we continue by initializing $F_0 = I$ \\ \\  \par

\textbf{2. Step: First Transition}\\
Check if $F_0 \land T \Rightarrow P'$, by testing if $F_0 \land T \land \bar P'$ is satisfiable: 
\begin{equation*}
\underbrace{\bar x_1 \land \bar x_2 \land \bar x_3}_{F_0} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T} \land \underbrace{ x_1' \land x_2' \land x_3'}_{\bar P'}
\end{equation*}
Which is not satisfiable because $\bar x_1 \land (x_1 \lor \bar x_2') \land x_2'$ is unsatisfiable. We do not generate a proof-obligation, so that we can skip the blocking-phase and continue on with the propagation-phase. \\ \\ \par

\textbf{3. Step: First Propagation-Phase} \\
Initialize the new frame $F_1 = P$ \\
We need to check each clause $c$ in $F_0$ if $F_0 \land T \land \bar c'$ is unsatisfiable to strengthen $F_1$.
\begin{itemize}
\item $c = \bar x_1:$
\begin{equation*}
\underbrace{\bar x_1 \land \bar x_2 \land \bar x_3}_{F_0} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T} \land \underbrace{x_1'}_{\bar c'}
\end{equation*}
The conjunction is satisfiable with assignment $(\bar x_1, \bar x_2, \bar x_3, x_1', \bar x_2', \bar x_3')$ \\ 
We do not need to add $\bar x_1$ to $F_1$. \\

\item $c = \bar x_2:$
\begin{equation*}
\underbrace{\bar x_1 \land \bar x_2 \land \bar x_3}_{F_0} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T} \land \underbrace{x_2'}_{\bar c'}
\end{equation*}
The conjunction is unsatisfiable because $\bar x_1 \land (x_1 \lor \bar x_2') \land x_2'$ is not satisfiable \\ We add $\bar x_2$ to $F_1$ resulting in $F_1 = P \land \bar x_2$. \\

\item $c = \bar x_3:$
\begin{equation*}
\underbrace{\bar x_1 \land \bar x_2 \land \bar x_3}_{F_0} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T} \land \underbrace{x_3'}_{\bar c'}
\end{equation*}
The conjunction is unsatisfiable because $\bar x_2 \land (x_2 \lor \bar x_3') \land x_3'$ is not satisfiable \\ We add $\bar x_3$ to $F_1$ resulting in $\rightarrow F_1 = P \land \bar x_2 \land \bar x_3$
\end{itemize}
There are no clauses left, the first propagation-phase is done, resulting in the new frame:
\begin{equation*}
 F_1 = (\bar x_1 \lor \bar x_2 \lor \bar x_3) \land \bar x_2 \land \bar x_3
\end{equation*}
and because $F_1 \not\equiv F_0$ we continue. \\ \\ \par

\textbf{4. Step: Second Transition} \\
Check if $F_1 \land T \Rightarrow P'$ by testing $F_1 \land T \land \bar P'$ for satisfiability: 
\begin{equation*}
\underbrace{(\bar x_1 \lor \bar x_2 \lor \bar x_3) \land \bar x_2 \land \bar x_3}_{F_1} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T} \land \underbrace{x_1' \land x_2' \land x_3'}_{ \bar P'}
\end{equation*}
Which is unsatisfiable because $\bar x_2 \land (x_2 \lor \bar x_3') \land x_3'$ is not satisfiable. We do not generate a proof-obligation so we continue with the second propagation-phase. \\ \\ \par

\textbf{5. Step: Second Propagation-Phase} \\
Initialize new frame $F_2 = P$ \\
We need to check each clause $c$ in $F_1$ if $F_1 \land T \land \bar c'$ is unsatisfiable to strengthen $F_2$. We skip $P$, as it is already part of $F_2$. \\ 
This works exactly as in the 3. step: \par
\begin{itemize}
\item $c = \bar x_2:$ 
\begin{equation*}
\underbrace{(\bar x_1 \lor \bar x_2 \lor \bar x_3) \land \bar x_2 \land \bar x_3}_{F_1} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T} \land \underbrace{x_2'}_{\bar c'}
\end{equation*}
The conjunction is satisfiable with assignment $(x_1, \bar x_2, \bar x_3, x_1', x_2', \bar x_3')$ \\
We do not need to add $\bar x_2$ to $F_2$ \\

\item $c = \bar x_3:$ 
\begin{equation*} 
\underbrace{(\bar x_1 \lor \bar x_2 \lor \bar x_3) \land \bar x_2 \land \bar x_3}_{F_1} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T} \land \underbrace{x_3'}_{\bar c'}
\end{equation*}
The conjunction is unsatisfiable because $\bar x_2 \land (x_2 \lor \bar x_3') \land x_3'$ is not satisfiable. \\ We add $\bar x_3$ to $F_2$ resulting in $F_2 = P \land \bar x_3$
\end{itemize}
As there are no clauses left, the second propagation-phase concludes, resulting in the new frame:
\begin{equation*}
F_2 = (\bar x_1 \lor \bar x_2 \lor \bar x_3) \land \bar x_3
\end{equation*}
and because $F_2 \not\equiv F_1$ we continue. \\ \\

\textbf{6. Step: Third Transition} \\ Check if $F_2 \land T \Rightarrow P'$ by testing $F_2 \land T \land \bar P'$ for satisfiability:
\begin{equation*}
\underbrace{(\bar x_1 \lor \bar x_2 \lor \bar x_3) \land \bar x_3}_{F_2} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T} \land \underbrace{x_1' \land x_2' \land x_3'}_{ \bar P'}
\end{equation*}
This time $F_2 \land T \land \bar P'$ is satisfiable with assignment $( \underbrace{x_1, x_2, \bar x_3}_{s}, x_1', x_2', x_3')$, we get the new bad state $s = x_1 \land x_2 \land \bar x_3$, and generate a proof-obligation $(s, 2)$, which we now try to block in the blocking-phase. \\ \\ \par

\textbf{7. Step: First Blocking-Phase} \\ Try to block proof-obligation $(s, 2)$ by checking if $F_1 \land T \land s'$ is satisfiable.
\begin{equation*}
\underbrace{(\bar x_1 \lor \bar x_2 \lor \bar x_3) \land \bar x_2 \land \bar x_3}_{F_1} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T} \land \underbrace{x_1' \land x_2' \land \bar x_3'}_{ s'}
\end{equation*}

This is again satisfiable with assignment $(\underbrace{x_1, \bar x_2, \bar x_3}_{\text{q}}, x_1', x_2', \bar x_3')$, we get the bad state $q = x_1 \land \bar x_2 \land \bar x_3$ and generate a new proof-obligation $(q, 1)$. \\ \\ \par

We try to block proof-obligation $(q, 1)$ by checking if $F_0 \land T \land q'$ is satisfiable.
\begin{equation*}
\underbrace{\bar x_1 \land \bar x_2 \land \bar x_3}_{F_0} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T} \land \underbrace{x_1' \land \bar x_2' \land \bar x'_3}_{ q'}
\end{equation*}

This too is satisfiable with assignment $(\underbrace{\bar x_1, \bar x_2, \bar x_3}_{I}, x_1', \bar x_2', \bar x_3')$, we get the bad state $I = x_1 \land \bar x_2 \land \bar x_3$ and generate a new proof-obligation $(I, 0)$.

With that we have found a counter-example, resulting in the termination of the algorithm, returning the counter-example trace: 
\begin{equation*}
\underbrace{\bar x_1 \land \bar x_2 \land \bar x_3}_{I} \rightarrow \underbrace{x_1 \land \bar x_2 \land \bar x_3}_{q} \rightarrow \underbrace{x_1 \land x_2 \land \bar x_3}_{s} \rightarrow \underbrace{x_1 \land x_2 \land x_3}_{\bar P}   
\end{equation*}

If we now assume proof-obligation $(s, 2)$ would have been blocked, meaning $F_1 \land T \land s'$ was unsatisfiable, then we would have updated $F_2 = F_2 \land \bar s$ making absolutely sure that $s$ is not reachable, every future proof-obligation containing $s$ would have been blocked by $F_2$.

\pagebreak

\subsection{With Passing Property}
To show a transition system with an inductive invariant, consider $B = (X, I, T)$, where
\begin{itemize}
\item $X = \{x_1, x_2\}$
\item $I = \bar x_1 \land \bar x_2 $
\item  $T = ( x_1 \lor \bar x_2 \lor x_2') \land (x_1 \lor x_2 \lor \bar x_1') \land (\bar x_1 \lor x_1') \land (\bar x_1 \lor \bar x_2') \land (x_2 \lor \bar x_2')$
\end{itemize}
and corresponding transition graph: \par

\begin{figure}[H]
\centering
\begin{tikzpicture}[%
    ->,
    >=stealth', shorten >=1pt, auto,
    node distance=5cm, scale=1, 
    transform shape, align=center,    
    state/.style={%
      circle,
      minimum size=3.5cm,
      scale=0.7,
      draw
    }
  ]
    \node[initial, state](1){$\bar x_1 \land \bar x_2$};
    
    \node[state] (2) [right of=1] {$\bar x_1 \land x_2$};
    
    \node[state] (3) [right of=2] {$ x_1 \land x_2$};
    
    \node[state] (4) [right of=3] {$ x_1 \land \bar x_2$};
    
    
 	  \path (1) edge [loop above] node {} (1)
 	  (2) edge [loop above] node {} (2)
 	  (2) edge [] node {} (3)
 	  (3) edge [] node {} (4)
 	  (4) edge [loop above] node {} (4)

 	  ;

    
);
  \end{tikzpicture}
  \caption{Transition Graph of $B$}
 \end{figure}
 \label{ex1}  


Now given the property $P = \bar x_1 \lor x_2$, we want to check whether the bad state $\bar P = x_1 \land \bar x_2$ is reachable: \\ \par

\textbf{1. Step: Check for 0-Counter-Example} \\ 
We need to make sure that $I \Rightarrow P$, we do that by testing if $I \land \bar P$ is satisfiable: 
\begin{equation*}
\underbrace{\bar x_1 \land \bar x_2}_{I} \land \underbrace{x_1 \land \bar x_2}_{\bar P}
\end{equation*}
Which is unsatisfiable because $\bar x_1 \land x_1$, that means there is no 0-counter-example, we continue by initializing $F_0 = I$\\ \\ \par

\textbf{2. Step: First Transition} \\
Check if $F_0 \land T \Rightarrow P'$ by testing if $F_0 \land T \land \bar P'$ is satisfiable:
\begin{equation*}
\underbrace{\bar x_1 \land \bar x_2}_{F_0} \land \underbrace{( x_1 \lor \bar x_2 \lor x_2') \land (x_1 \lor x_2 \lor \bar x_1') \land (\bar x_1 \lor x_1') \land (\bar x_1 \lor \bar x_2') \land (x_2 \lor \bar x_2')}_{T} \land \underbrace{x_1' \land \bar x_2'}_{\bar P'}
\end{equation*}

Which is unsatisfiable because $\bar x_1 \land \bar x_2 \land (x_1 \lor x_2 \lor x_1') \land \bar x_1'$ is not satisfiable. We generate no proof-obligation and continue with the propagation-phase. \\ \\

\textbf{3. Step: First Propagation-Phase} \\ Initialize the new frame $F_1 = P$ \\
For each clause $c$ in $F_0$ we check $F_0 \land T \land \bar c'$ for unsatisfiability to strengthen $F_1$.
\begin{itemize}
\item $c = \bar x_1:$
\begin{equation*}
\bar x_1 \land \bar x_2 \land T \land x_1'
\end{equation*}
The conjunction is unsatisfiable because $\bar x_1 \land \bar x_2 \land (x_1 \lor x_2 \lor x_1') \land \bar x_1'$ is not satisfiable.\\ We add $\bar x_1$ to $F_1$ resulting in $F_1 = P \land \bar x_1$ \\

\item$c = \bar x_2:$
\begin{equation*}
\bar x_1 \land \bar x_2 \land T \land x_2'
\end{equation*}
The conjunction is unsatisfiable because $\bar x_1 \land \bar x_2 \land (x_2 \lor \bar x_2') \land x_2'$ is not satisfiable. \\ We add $\bar x_2$ to $F_1$ resulting in $F_1 = P \land \bar x_1 \land \bar x_2$
\end{itemize}
That concludes the propagation-phase resulting in the new frame
\begin{equation*}
F_1 =(\bar x_1 \lor x_2) \land \bar x_1 \land \bar x_2
\end{equation*}
and because $F_1 \not\equiv F_0$ we continue. \\ \\ \\

\textbf{4. Step: Second Transition} \\
Check if $F_1 \land T \Rightarrow P'$ by testing if $F_1 \land T \land \bar P'$ is satisfiable: 
\begin{equation*}
(\bar x_1 \lor x_2) \land \bar x_1 \land \bar x_2 \land T \land x_1' \land \bar x_2'
\end{equation*}
Which is unsatisfiable because $\bar x_1 \land \bar x_2 \land (x_1 \lor x_2 \lor \bar x_1') \land x_1'$ is not satisfiable. We again do not generate a proof-obligation, so that we continue with the second propagation-phase. \\ \\ \par

\textbf{5. Step: Second Propagation-Phase} \\
Initialize the new frame $F_2 = P$ \\
We need to check every clause $c$ in $F_1$ if $F_1 \land T \land \bar c'$ is unsatisfiable to strengthen $F_2$.\\ We  skip $P$. 
\begin{itemize}
\item $c = \bar x_1:$
\begin{equation*}
(\bar x_1 \lor x_2) \land \bar x_1 \land \bar x_2 \land T \land x_1'
\end{equation*}
The conjunction is unsatisfiable because $\bar x_1 \land \bar x_2 \land (x_1 \lor x_2 \lor \bar x_1') \land x_1'$ is not satisfiable \\
We add $\bar x_1$ to $F_2$ resulting in
$F_2 = P \land \bar x_1$ \\

\item $c = \bar x_2:$ 
\begin{equation*}
(\bar x_1 \lor x_2) \land \bar x_1 \land \bar x_2 \land T \land x_2'
\end{equation*}
The conjunction is unsatisfiable because $\bar x_2 \land (x_2 \lor \bar x_2') \land x_2'$ is not satisfiable. \\
We add $\bar x_2$ to $F_2$ resulting in
$F_2 = P \land \bar x_1 \land \bar x_2$

\end{itemize}

With no more clauses left the second propagation-phase ends, resulting in 
\begin{equation*}
F_2 = (\bar x_1 \lor x_2) \land \bar x_1 \land \bar x_2 \equiv F_1
\end{equation*}
The algorithm terminates returning that the property always holds and
\begin{equation*}
(\bar x_1 \lor x_2) \land \bar x_1 \land \bar x_2
\end{equation*}
 being an inductive invariant.

\section{Possible Improvements}
The most time consuming part of the algorithm is the solving of SAT-queries, the larger the query the more time it takes. To improve this there are several ways to keep SAT-queries small:

\subsection{Generalization of States}
Blocking one state at a time is ineffective.  \\
When blocking a state $s$ do not add $\bar s$ but try to find and add a cube $c \subseteq \bar s$. \\
Most modern SAT-solver not only return unsatisfiable but also a reason for it, either by an UNSAT-core or through a final conflict-clause. Both of them deliver information about which clauses were actually used in the proof. To find a $c$ just remove unused clauses of $s$.

\subsection{Ternary Simulation}
To reduce proof-obligations it is possible to eliminate not needed state variables by checking a satisfying assignment using ternary simulation. \\
Ternary logic extends the binary logic by introducing a new valuation: $X$, called unknown, and new rules:
\begin{align*}
(X \land false) &= false, \\ (X \land true) &= X, \\ (X \land X) &= X, \\ \bar X &= X
\end{align*}
To remove state variables, set one variable at a time to $X$ and try to transition to a next state using the transition relation, the variable is needed if $X$ propagates into the next state, if it does not remove the variable from the proof-obligation. \\ \\
Reconsider the prior \hyperref[ex2]{example's} first blocking phase resulting in the proof-obligation$(q, 1)$ with bad state $q = x_1 \land \bar x_2 \land \bar x_3$, we now want to reduce that proof-obligation using ternary simulation: \par


First of all, the transition formula:
\begin{equation*}
\underbrace{x_1 \land \bar x_2 \land \bar x_3}_{q} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T}
\end{equation*}

Now set $x_1 = X$: \\
\begin{equation*}
\underbrace{X \land \bar x_2 \land \bar x_3}_{q} \land \underbrace{(X \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T}
\end{equation*}
$(X \lor \bar x_2')$ is unknown meaning that $x_1$  is needed. \\ \\

Now set $x_2 = X$: \\
\begin{equation*}
\underbrace{x_1 \land X \land \bar x_3}_{q} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (X \lor \bar x_3') \land ( X \lor x_3')}_{T}
\end{equation*}

$(X \lor \bar x_3')$ is unknown meaning that $x_2$  is needed as well. \\ \\

Now set $x_3 = X$: \\
\begin{equation*}
\underbrace{x_1 \land \bar x_2 \land X}_{q} \land \underbrace{(x_1 \lor \bar x_2' ) \land ( \bar x_1 \lor x_2') \land (x_2 \lor \bar x_3') \land ( \bar x_2 \lor x_3')}_{T}
\end{equation*}
Because there is no clause being unknown, $x_3$ can be removed from the proof-obligation. We get the reduced proof-obligation$(x_1 \land \bar x_2, 1)$

\pagebreak


\chapter{PDR as Software Checker} \label{sec3}
We see that PDR is a useful and efficient hardware-model checking technique. If we want to use it on software, we need to \textsl{lift} the algorithm from bit-level propositional logic to first-order logic. There are multiple ways to do that, the following approach is based on the technique described by Lange et al. \cite{Zitat05}. \\ To use PDR on software we first need some new definitions and other preliminaries.

\section{Preliminaries}
A control flow graph (CFG) $\mathcal{A} = (X, L, G, \ell_0, \ell_E)$ is a tuple, consisting of a finite set of variables $X$, a finite set of locations $L$, a finite set of transitions $G \subseteq L \times FO \times L$, $FO$ being a quantifier free first-order logic formula over variables in $X$ and $X' = \{x \in X \ | \ x' \in X'\}$, an initial location $\ell_0 \in L$, and an error location $\ell_E \in L$.\par

For example consider the CFG $\mathcal{A} = (X, L, G, \ell_0, \ell_E)$, where
\begin{itemize}
\item $X = \{x\}$
\item $L = \{\ell_0, \ell_1, \ell_2, \ell_3, \ell_E\}$
\item $G = \{(\ell_0, x' := 0, \ell_1), (\ell_1, x' := x + 1, \ell_2), (\ell_2, x = 1, \ell_E), (\ell_2, x \neq 1, \ell_3) \} $
\end{itemize}
\pagebreak
with the graph: \\

\begin{figure}[H]
\centering
\begin{tikzpicture}[%
    ->,
    >=stealth', shorten >=1pt, auto,
    node distance=3cm, scale=1, 
    transform shape, align=center,    
    state/.style={%
      circle,
      minimum size=1.5cm,
      scale=1,
      draw
    }
  ]
    \node[initial above, state](1){$\ell_0$};
    
    \node[state] (2) [below of=1] {$\ell_1$};
    
    \node[state] (3) [below of=2] {$\ell_2$};
    
    \node[state] (4) [below right of=3] {$\ell_3$};
    
    \node[state] (5) [below left of=3] {$\ell_E$};
    
    
 	  \path (1) edge node {$x := 0$} (2)
 	  (2) edge node {$x := x + 1$} (3)
 	  (3) edge node {$x \neq 1$} (4)
 	  (3) edge [edge label={$x = 1$}, swap] node {} (5)
 	  ;

    
);
  \end{tikzpicture}
  \caption{Graph of $\mathcal{A}$}
 \end{figure}
 \label{ex1} 

The transition formula $T_{\ell_1 \rightarrow \ell_2}$ from one location $\ell_1$ to another location $\ell_2$ is defined as:
\begin{equation*}
T_{\ell_1 \rightarrow \ell_2} = \begin{cases} (\ell_1, t, \ell_2), & (\ell_1, t, \ell_2) \in G \\
                     false, & otherwise
       \end{cases}
\end{equation*}

Resulting in the global transition formula: \\
$$ T = \bigvee_{(\ell_1, t, \ell_2) \in G} T_{\ell_1 \rightarrow \ell_2}$$

The lifted algorithm no longer works on boolean transition systems but on CFGs. It tries to prove whether $\ell_E$ is reachable, by finding a feasible path from $\ell_0$ to $\ell_E$.

\section{Lifted Algorithm}
There are four main differences between bit-level PDR and lifted PDR:
\begin{itemize}

\item Instead of a global set of Frames $[F_0, ..., F_k]$ assign each program location $\ell \in L \backslash \{\ell_E\}$ a local set of frames $[F_{0, \ell}, ..., F_{k, \ell}]$. Each frame is now a cube of first-order formulas. As there are now multiple traces, proof-obligations get extended by another parameter, lifted proof-obligations are tuples $(t, \ell, i)$ where $t$ is a first-order formula, $\ell$ describes the location where $t$ has to be blocked, and $i$ is a frame number, called level in the lifted algorithm.

\item 
Because the states in a CFG are no formulas, the lifted algorithm no longer blocks states but transitions, there are no bad states only bad transitions.

\item Because of the structure of the CFA, it is already known which states lead to the error location, as it is easy to extract the transitions in $G$ that have $\ell_E$ as target, making the next transition phase, that was used to find proof-obligations before, obsolete. \\ If there exists a transition to $\ell_E$ there will be an initial proof-obligation in each iteration of the algorithm, making the blocking-phase no longer optional.

\item The propagation-phase is slimmed, it only checks for termination. In the phase the algorithm checks the frames to find a level $i$ where all locations have a fixpoint, meaning  $F_{i, \ell} = F_{i-1, \ell}$ for every location $\ell \in L \backslash \{l_E \}$, $i$ is called a global fixpoint position. There is no more propagating formulas forward.
\end{itemize}

\hspace*{5cm}

\textsl{In more detail}: \\
Given a CFG $\mathcal{A} = (X, L, G, \ell_0, \ell_E)$ we want to check if $\ell_E$ is reachable: \par
Again start with checking for a 0-counter-example, this is easily done by looking at $\ell_0$ if $\ell_0 = \ell_E$ terminate and return that $\ell_E$ is indeed reachable, if $\ell_0 \neq \ell_E$ initialize level 0 frames for all locations $\ell \in L \backslash \{\ell_0, \ell_E\}$ as \texttt{false}, and for $\ell_0$ as \texttt{true}. \par
Let $k$ be the current level, so that each location $\ell \in L \backslash \{\ell_E\}$ has frames $[F_{0, \ell}, ..., F_{k, \ell}]$. \\
The algorithm repeats the following phases: \\

\textsl{1. Next Level} \\
Initialize for each $\ell \in L \backslash \{\ell_E\}$ a new frame $k + 1$ as \texttt{true}. \\
For each location $\ell \in L$ where $(\ell, t, \ell_E) \in G$ generate an initial proof-obligation $(t, \ell, k)$. \\

\pagebreak

\textsl{2. Blocking-Phase} \\
If there are proof-obligations: \\
Take proof-obligation $(t, \ell, i)$ with the lowest $i$ and check for each predecessor location $\ell_{pre}$ if the formula:
\begin{equation*}
F_{i - 1, \ell_{pre}} \land T_{\ell_{pre} \rightarrow \ell} \land t'
\end{equation*}
is satisfiable.
\begin{itemize}
\item If it is \textsl{satisfiable}, it means that $t$ could not be blocked at $\ell$ on level $i$, generate a new proof-obligation $(p, \ell_{pre}, i-1)$ where $p$ is the weakest precondition of $t$.

\item If the formula is \textsl{unsatisfiable}, strengthen each frame $F_{j, \ell}$, $j \leq i$ with $\bar t$, meaning $F_{j, \ell} = F_{j, \ell} \land \bar t$, blocking $t$ at $\ell$ on level $i$.
\end{itemize}

This continues recursively until either a proof-obligation $(d, \ell, 0)$ is generated, proving that there exists a feasible path to $\ell_E$ terminating the algorithm, or there is no proof-obligation left. \\

\textsl{3. Propagation-Phase} \\
Check the frames if there exists a global fixpoint position $i$ where
\begin{equation*}
F_{i-1, \ell} = F_{i, \ell}
\end{equation*}
for every location $\ell \in L \backslash \{l_E \}$. \\
If there is such an $i$ the algorithm terminates returning that $\ell_E$ is not reachable. \\

\pagebreak

To illustrate the lifted algorithm further consider the updated pseudo-code: \\ \\

\begin{algorithm}[H] 
\caption{lifted-PDR-prove}
\begin{algorithmic}[1]
\Procedure{lifted-PDR-prove}{$L, G$}
\State check for 0-counter-example
\State $\ell_0.trace.push(new\ frame(true))$
\ForAll {$\ell \in L \backslash \{ \ell_0, \ell_E\}$}
	\State $\ell.trace.push(new\ frame(false))$
\EndFor
\State $level := 0$
\Statex
\Loop
	\ForAll {$\ell \in L \backslash \{\ell_E\}$}
		\State $\ell.trace.push(new\ frame(true))$
	\EndFor
	\State $level:= level + 1$
	\State get initial proof-obligations 
	\Statex
	\While {$\exists$ proof-obligation $(t, \ell, i),$} 
	\State Recursively block proof-obligation
	\If {a proof-obligation$(p, \ell, 0)$ is generated}
		\State{\Return{false}}
	\EndIf
	\EndWhile

	\Statex	
	\For {$i = 0;\ i \leq level;\ i:= i + 1$}
		\For {$\ell \in L \backslash \{l_E \}$}
			\If {$\ell.trace[i] \neq \ell.trace[i-1]$}
				\State{break}
			\EndIf
		\EndFor
		\State{\Return{true}}
	\EndFor
\EndLoop
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Example}
\subsection{Reachable Error State}
To show an application of the lifted algorithm reconsider the example from earlier, we have CFA  $\mathcal{A} = (X, L, G, \ell_0, \ell_E)$ where
\begin{itemize}
\item $X = \{x\}$
\item $L = \{\ell_0, \ell_1, \ell_2, \ell_3, \ell_E\}$
\item $G = \{(\ell_0, x := 0, \ell_1), (\ell_1, x := x + 1, \ell_2), (\ell_2, x = 1, \ell_E), (\ell_2, x \neq 1, \ell_3) \}$
\end{itemize}

We now want to verify whether $\ell_E$ is reachable using the lifted algorithm: \\ \\

\textbf{1. Step: Check for 0-Counter-Example} \\
Is $\ell_0 = \ell_E$?  \\
No, we continue with initializing level 0 by adding to each $\ell \in L \backslash \{\ell_0, \ell_E\}$ a new frame $F_{0, \ell} = false$, for $\ell_0$ adding $F_{0, \ell_0} = true$: \\ \\

\begin{center}
\begin{tabular}{c | c}
\backslashbox{location}{level} & 0 \\
\hline
$\ell_0$ & $true$ \\
$\ell_1$ & $false$ \\
$\ell_2$ & $false$ \\
$\ell_3$ & $false$ \\
\end{tabular}
\end{center}

\hspace*{5cm}

\textbf{2. Step: Next Level} \\
We initialize new frames for level 1 as \texttt{true}: \\

\begin{center}
\begin{tabular}{c | c |c}
\backslashbox{location}{level} & 0 & 1\\
\hline
$\ell_0$ & $true$ & $true$ \\
$\ell_1$ & $false$ & $true$ \\
$\ell_2$ & $false$ & $true$ \\
$\ell_3$ & $false$ & $true$ \\

\end{tabular}
\end{center}

\hspace*{3cm}

To generate the initial proof-obligations, we check $G$ and take the transitions where $\ell_E$ is the target. \\ We see, there is one transition $(\ell_2, x = 1, \ell_E)$, that means we have to block $x = 1$ at $\ell_2$ on level 1, resulting in the initial proof-obligation $(x = 1, \ell_2, 1).$ \\ \\ \par

\textbf{3. Step: First Blocking Phase} \\
We need to block the initial proof-obligation $(x = 1, \ell_2, 1)$. Let $\ell_{pre}$ be a predecessor of $\ell_2$, we need to check the formula:
\begin{equation}
F_{0, l_{pre}} \land T_{\ell_{pre} \rightarrow \ell_2} \land x' = 1
\end{equation}
for satisfiability. As there is only one predecessor $\ell_1$ we test:
\begin{equation*}
\underbrace{false}_{F_{0, \ell_1}} \land \underbrace{x' := x + 1}_{T_{\ell_1 \rightarrow \ell_2}} \land x' = 1
\end{equation*}

Which is unsatisfiable \\
We add $\overline{(x=1)} \equiv x \neq 1$ to $F_{0, \ell_2}$ and $F_{1, \ell_2}$, blocking $x=1$ at $\ell_2$ on level 1. \\

\begin{center}
\begin{tabular}{c | c |c}
\backslashbox{location}{level} & 0 & 1\\
\hline
$\ell_0$ & $true$ & $true$ \\
$\ell_1$ & $false$ & $true$ \\
$\ell_2$ & $false \land x \neq 1$ & $true \land x \neq 1$ \\
$\ell_3$ & $false$ & $true$ \\

\end{tabular}
\end{center}

\hspace*{3cm}


Because there are no proof-obligations left we continue with the propagation-phase. \\ \\ \par

\textbf{4. Step: First Propagation-Phase} \\
Check if there exists a global fixpoint position $i$ where
\begin{equation*}
F_{i-1, \ell} = F_{i, \ell}
\end{equation*}
for every location $\ell \in L \backslash \{l_E \}$. \\
We see there is no such $i$, we continue with the next level. \\ \\ \par


\textbf{5. Step: Next Level} \\
We initialize new frames for level 2 as \texttt{true}: \\
\begin{center}
\begin{tabular}{c | c |c|c}
\backslashbox{location}{level} & 0 & 1 & 2\\
\hline
$\ell_0$ & $true$ & $true$ & $true$ \\
$\ell_1$ & $false$ & $true$ & $true$ \\
$\ell_2$ & $false \land x \neq 1$ & $true \land x \neq 1$ & $true$ \\
$\ell_3$ & $false$ & $true$ & $true$ \\

\end{tabular}
\end{center}

\hspace*{3cm}

Again generate the initial proof-obligation which is the same as before but on level 2 now, we have initial proof-obligation $(x = 1, \ell_2, 2)$ \\ \\ \par

\textbf{6. Step: Second-Blocking Phase} \\
We need to block the proof-obligation $(x = 1, \ell_2, 2)$ by testing
\begin{equation*}
\underbrace{true}_{F_{1, \ell_1}} \land \underbrace{x' := x + 1}_ {T_{\ell_1 \rightarrow \ell_2}} \land x' = 1
\end{equation*}
for satisfiability. Which is satisfiable with $ p = (x = 0)$. Because $p$ being also the weakest precondition, we generate a new proof-obligation $(p, \ell_1, 1)$, meaning we need to block $p$ at location $\ell_1$ on level 1. \par
Take the new proof-obligation $(x=0, \ell_1, 1)$ and check 
\begin{equation*}
\underbrace{true}_{F_{0, \ell_0}} \land \underbrace{x' := 0}_ {T_{\ell_{0} \rightarrow \ell_1}} \land \underbrace{x' = 0}_{p'}
\end{equation*}
for satisfiability. \\
Which is valid, with \texttt{true} being the weakest precondition, we generate the new proof-obligation $(true, l_0, 0)$ and because this obligation is on level 0 we terminate, stating that $\ell_E$ is reachable by the counter-example trace:
\begin{equation*}
\ell_0 \rightarrow \ell_1 \rightarrow \ell_2 \rightarrow \ell_E
\end{equation*}


\pagebreak

\subsection{Unreachable Error State}
To show a CFA with an unreachable error state consider $\mathcal{B} = (X, L, G, \ell_0, \ell_E),$ where
\begin{itemize}
\item $X = \{x, y\}$
\item $L = \{\ell_0, \ell_1, \ell_2, \ell_E\}$
\item $G = \{(\ell_0, x' := 0 \land y' := x', \ell_1), (\ell_1, x' := x+1 \land y' := y+1, \ell_1),\\ (\ell_1, x = y, \ell_2), (\ell_1, x \neq y, \ell_E) \}$
\end{itemize}

with graph: \\


\begin{figure}[H]
\centering
\hspace*{3cm}
\begin{tikzpicture}[%
    ->,
    >=stealth', shorten >=1pt, auto,
    node distance=3cm, scale=1, 
    transform shape, align=center,    
    state/.style={%
      circle,
      minimum size=1.5cm,
      scale=1,
      draw
    }
  ]
    \node[initial above, state](1){$\ell_0$};
    
    \node[state] (2) [below of=1] {$\ell_1$};
    
    \node[state] (3) [below left of=2] {$\ell_2$};
    
    \node[state] (4) [below right of=2] {$\ell_E$};
    
    
    
 	  \path (1) edge node {$x := 0 \land y := x$} (2)
 	  (2) edge [loop right] node {$x := x + 1 \land y := y + 1$} (2)
 	  (2) edge [edge label={$x = y$}, swap] node {} (3)
 	  (2) edge [edge label={$x \neq y$}, swap] node {} (4)
 	  ;

    
);
  \end{tikzpicture}
  \caption{Graph of $\mathcal{B}$}
 \end{figure}
 \label{ex1} 

We now want to check whether $\ell_E$ is reachable, using the lifted algorithm: \par

\textbf{1. Step: Check for 0-Counter-Example} \\
Is $\ell_0 = \ell_E$? \\
No, we continue with initializing level 0 by adding to each $\ell \in L \backslash \{\ell_0, \ell_E\}$ a new frame $F_{0, \ell} = false$, for $\ell_0$ adding $F_{0, \ell_0} = true$. \\ \\

\begin{center}
\begin{tabular}{c | c}
\backslashbox{location}{level} & 0 \\
\hline
$\ell_0$ & $true$ \\
$\ell_1$ & $false$ \\
$\ell_2$ & $false$ \\

\end{tabular}
\end{center}

\hspace*{5cm}


\textbf{2. Step: Next Level} \\
We initialize new frames for level 1 as \texttt{true}: \\

\begin{center}
\begin{tabular}{c | c |c}
\backslashbox{location}{level} & 0 & 1\\
\hline
$\ell_0$ & $true$ & $true$ \\
$\ell_1$ & $false$ & $true$ \\
$\ell_2$ & $false$ & $true$ \\

\end{tabular}
\end{center}



We see there is only one transition leading to $\ell_E$, $(\ell_1, x \neq y, \ell_E)$. We get the initial proof-obligation $(x \neq y, \ell_1, 1)$. \\ \\ \par
\textbf{3. Step: First Blocking Phase} \\
To block the initial proof-obligation $(x \neq y, \ell_1, 1)$ we check each predecessor of $\ell_1$:

\begin{itemize}
\item predecessor: $\ell_0$
\begin{equation*}
\underbrace{true}_{F_{0, \ell_0}} \land \underbrace{x' := 0 \land y' := x'}_{T_{\ell_0 \rightarrow \ell_1}} \land  x' \neq y'
\end{equation*}
Which is unsatisfiable, we add $\overline{(x \neq y)} \equiv x = y$ to $F_{0, \ell_1}$ and $F_{1, \ell_1}$: \\

\begin{center}
\begin{tabular}{c | c |c}
\backslashbox{location}{level} & 0 & 1\\
\hline
$\ell_0$ & $true$ & $true$ \\
$\ell_1$ & $false \land x = y$ & $true \land x = y$ \\
$\ell_2$ & $false$ & $true$ \\

\end{tabular}
\end{center}
\hspace*{3cm}

\item predecessor: $\ell_1$
\begin{equation*}
\underbrace{false \land x = y}_{F_{0, \ell_1}} \land \underbrace{x' := x + 1 \land y' := y + 1'}_{T_{\ell_1 \rightarrow \ell_1}} \land  x' \neq y'
\end{equation*}
Which is unsatisfiable as well, but because $x = y$ has already been added to $F_{0, \ell_1}$ and $F_{1, \ell_1}$ we move on.

\end{itemize}
 As there are no proof-obligations left, we continue with the first propagation-phase. \\ \\ \par
 
\textbf{4. Step: First Propagation-Phase} \\
Check if there exists a global fixpoint position $i$ where
\begin{equation*}
F_{i-1, \ell} = F_{i, \ell}
\end{equation*}
for every location $\ell \in L \backslash \{l_E \}$. \\
We see there is no such $i$, we continue with the next level. \\ \\ \par

\textbf{5. Step: Next Level} \\
We initialize new frames for level 2 as \texttt{true}: \\
\begin{center}
\begin{tabular}{c | c |c|c}
\backslashbox{location}{level} & 0 & 1 & 2\\
\hline
$\ell_0$ & $true$ & $true$ & $true$ \\
$\ell_1$ & $false \land x = y$ & $true \land x = y$ & $true$\\
$\ell_2$ & $false$ & $true$ & $true$ \\

\end{tabular}
\end{center}
\hspace*{3cm}

Again we generate the initial proof-obligation which is the same as before but on level 2 now, we have the initial proof-obligation $(x \neq y, \ell_1, 2).$ \\ \\ \par


\textbf{6. Step: Second Blocking Phase} \\
To block proof-obligation $(x \neq y, \ell_1, 2)$ we check the predecessors of $\ell_1$:

\begin{itemize}
\item predecessor: $\ell_0$
\begin{equation*}
\underbrace{true}_{F_{1, \ell_0}} \land \underbrace{x' := 0 \land y' := x'}_{T_{\ell_0 \rightarrow \ell_1}} \land  x' \neq y'
\end{equation*}
Which is unsatisfiable, we add $\overline{(x \neq y)} \equiv x = y$ to $F_{0, \ell_1}$, $F_{1, \ell_1}$ and $F_{2, \ell_1}$:

\begin{center}
\begin{tabular}{c | c |c|c}
\backslashbox{location}{level} & 0 & 1 & 2\\
\hline
$\ell_0$ & $true$ & $true$ & $true$ \\
$\ell_1$ & $false \land x = y$ & $true \land x = y$ & $true \land x = y$ \\
$\ell_2$ & $false$ & $true$ & $true$ \\

\end{tabular}
\end{center}
\hspace*{3cm}

\item predecessor: $\ell_1$
\begin{equation*}
\underbrace{true \land x = y}_{F_{1, \ell_1}} \land \underbrace{x' := x + 1 \land y' := y + 1}_{T_{\ell_1 \rightarrow \ell_1}} \land  x' \neq y'
\end{equation*}
Which is unsatisfiable as well, but because $x = y$ has already been added to $F_{0, \ell_1}$, $F_{1, \ell_1}$, and $F_{2, \ell_1}$ we move on.
\end{itemize}

As there are no proof-obligations left, we continue with the second propagation-phase \\ \\ \par

\textbf{7. Step: Second Propagation-Phase} \\

\begin{center}
\begin{tabular}{c | c ? c |c ?}
\backslashbox{location}{level} & 0 & 1 & 2\\
\hline
$\ell_0$ & $true$ & $true$ & $true$ \\
$\ell_1$ & $false \land x = y$ & $true \land x = y$ & $true \land x = y$ \\
$\ell_2$ & $false$ & $true$ & $true$ \\
 \multicolumn{1}{c}{} &  \multicolumn{1}{c}{} & \multicolumn{2}{c}{\upbracefill} \\[-1ex]
 \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{2}{c}{$\scriptstyle global\ fixpoint$}\\



\end{tabular}
\end{center}
\hspace*{3cm}

We see that level 1 equals level 2 on all locations, with that we found global fixpoint position $i = 2$, the forumulas at that position are the inductive invariants proving that $\ell_E$ is not reachable.


\section{Possible Improvements}

As shown above, lifting PDR from bit-level to control flow graphs is possible. The problem of large, time consuming queries to the solver remain however. Is it possible to lift the improvements of the bit-level algorithm too? \par

\textsl{Ternary Simulation} cannot be used on first-order formulas making it impossible to use it to reduce lifted proof-obligations. \par
Different generalization techniques are possible:
\subsection{Syntactical Analysis}
Given a cube $c$ remove $a \subseteq c$, if no variable of $a$ is assigned in $T$ and
\begin{itemize}
\item[1.] $a$ is already contained in a frame, or
\item[2.] there exists an \texttt{assume a} in $T$ \\ \\
\end{itemize} 


\subsection{Weakest Precondition}
The definition of the lifted algorithm above already contains an improvement, using weakest preconditions to find predecessors. Instead of generating multiple proof-obligations for each individual predecessor state, the weakest precondition covers all of them in a single one. \\ \\


\subsection{Disjunctive Normal Form}
After transforming the weakest precondition into its disjunctive normal form, each cube can be considered as a separate smaller proof-obligation, saving time on larger formulas.\\ \\

\subsection{Interpolation}
\textbf{TODO}
We are using interpolation on frames and pos not on traces.

\pagebreak


\chapter{Implementation in Ultimate}
\section{Introduction Ultimate}
\textbf{This good?} \\
Ultimate program analysis framework, based on \textsl{plugins} that can be executed one after another to form \textsl{toolchains} which can perform various tasks. A big advantage of this modularity is that it is relatively easy to implement new toolchains as a lot of plugins can be reused creating much less overhead. There are five types of plugins: 
\begin{itemize}
\item Source plugins define a file-to-model transformation

\item  Analyzer plugins take a model as input and modifies it

\item Generator plugins have a similar functionality as Analyzer plugins but they can additionally produce new models

\item Output plugins do not produce or modify anything, they write models into files

\item The last plugin cannot be used in toolchains per say, they act more like a library providing additional functionality to other plugins

\end{itemize}

\section{Implementation}
To implement PDR in Ultimate we chose to implement a new library plugin \textsl{Library-PDR}, that is used in the generator plugin \textsl{traceabstraction}. \\
\textbf{ToDo add specific details like how do we manage proof obligations, hoare triple checker etc}

\section{Improvements}
\subsection{Caching of Proof-Obligation Queue}
We always start each new level with the initial proof-obligation, and generate a chain of proof-obligations, until the most recent one is blocked, we then recursively block all predecessor obligations, adding new information to the frames. This chain of obligations does not change, once a new obligation is generated it needs to be blocked in each successive level.\\
Now as a result of the backwards search nature of PDR, each new level has to create that chain of proof-obligations from the beginning again. That results in a lot of overhead because we have to calculate the same chain of obligations times and times again. \par
%For example, let $i$ be the current level, we have seen and blocked the initial proof-obligation $i$ times, its successor obligation $i-1$ times and so on. \par
Our idea was to cache the proof-obligation queue and always start a new level with the latest generated one, so we save the process of generating already known obligations. \par For that we introduced a \textsl{global level} variable serving as the level counter, and changed the levels of each proof-obligation to be \textsl{subtracted} from the global level, with that every proof-obligation is at its corresponding level of generation. \par For example, the initial proof-obligation has its local level 0, so that $global\ level - 0 = global\ level$, because the initial obligation always is on the global level, take an obligation that we generate from the initial one, it has local level 1 so that global level - 1 means that this proof-obligation comes immediately after the initial one. \par
Something that cannot be saved is blocking of the previous proof-obligation chain, we can only ignore the chain of proof-obligations leading to the newest one, the chain of blocking the ones before up to the initial obligation is necessary, because otherwise the frames are not updated properly. We however found a way to shorten this as well, as described in the next point. \\ 
To illustrate this technique further, consider the following graphic: \\

\textbf{ToDo Graphic}

\begin{figure}[H]
\hspace*{-10mm}
\begin{tikzpicture} [decoration={brace,mirror,amplitude=7}]


\fill[black!20!white] (0,0) -- (0,\textwidth/2) -- (\textwidth/2,\textwidth/2) -- (\textwidth/2, 0) -- cycle;

% horizontal axis
\draw[-] (0,0) -- (\textwidth,0) node[below=3mm] {};


%1.
\filldraw (0,\textwidth/2) circle (3pt) node[align=right, below right, label={[xshift=2mm, yshift=1mm, below right]Initial Obligation}] {};

%connection 1. and 2.
\draw [thick, dotted, ->]
(0,\textwidth/2) --(\textwidth/6 - 1mm,\textwidth/3 + 1mm);

%2.
\filldraw (\textwidth/6,\textwidth/3) circle (3pt) node[align=center,   right=3mm] {1. Obligation: \\ generated by Initial};

%connection 2. and 3.
\draw [thick, dotted, ->]
(\textwidth/6,\textwidth/3) --(\textwidth/3 - 1mm,\textwidth/6 + 1mm);

%3.
\filldraw (\textwidth/3,\textwidth/6) circle (3pt) node[align=left,   left=3mm] {2. Obligation: \\ generated by 1.};

%connection 3. and 4.
\draw [thick, dotted, ->]
(\textwidth/3,\textwidth/6) --(\textwidth/2 - 1mm,0 + 1mm);

%4.
\filldraw (\textwidth/2,0) circle (3pt) node[align=center,   below] {Newest Obligation: \\ Generated by 2.};

%4 and 3'
\draw [->]
(\textwidth/2,0 ) -- (\textwidth - \textwidth/3 - 1mm,\textwidth/6 - 1mm);

%3.'
\filldraw (\textwidth - \textwidth/3,\textwidth/6) circle (3pt) node[align=right,   right=3mm] {2. Obligation: \\ Blocked};


%3' and 2'
\draw [->]
(\textwidth - \textwidth/3, \textwidth/6 ) -- (\textwidth - \textwidth/6 - 1mm,\textwidth/3 - 1mm);


%2.'
\filldraw (\textwidth - \textwidth/6,\textwidth/3) circle (3pt) node[align=center, left=3mm] {1. Obligation: \\ Blocked};


%connection 2.' and 1.'
\draw [->]
(\textwidth - \textwidth/6,\textwidth/3) -- (\textwidth - 1mm,\textwidth/2 - 1mm);


%1.'
\filldraw (\textwidth,\textwidth/2) circle (3pt) node[align=center,   left=3mm] {Initial Obligation: \\ Blocked};


% ranges
%\draw	(1,3.5) node{{\scriptsize Constant flux}};
%		(4,3.5) node{{\scriptsize Field weakening}};

\draw[thick, dotted] (\textwidth/2,0) -- (\textwidth/2,\textwidth/2) node[] {};



% Vertical axis
%\draw[] (0,0) -- (0,\textwidth/2) node[left=5mm] {};
% \draw[] (\textwidth,0) -- (\textwidth,\textwidth/2) node[left=5mm] {};

\draw [decorate] (\textwidth/2, \textwidth/2 + 3mm) -- node[above=3mm, align=center]{This chain of obligations \\ is always the same \\ on each new level} (0, \textwidth/2 + 3mm);

\end{tikzpicture}
\end{figure}
 

\subsection{Ignoring Already Blocked Proof-Obligations}
\textbf{ToDo more details} \\
Besides changing proof-obligations's levels, we also expanded them with a list of already seen and blocked SMT-solver queries. Before we consider a new call to the SMT-solver we first check the given query whether it has already been proven unsatisfiable, if so, we just copy the the frame from one level before and continue with the next obligation. If we prove an unknown query as unsatisfiable we add them to the list of blocked queries. \par
With this we save time on programs with a lot of proof-obligations for example in loops, where we see the same queries very often or when we have blocked the newest obligation and have to block the obligation chain back to the initial one.

\subsection{Using Preconditions}
As discussed in the improvements section of the lifted PDR algorithm, using weakest preconditions is a really useful addition to the way proof-obligations are generated. In our implementation we instead use just the precondition, because "assume" edges have a reeeaaaallly funky weakest precondition that lead to diverse errors.
\textbf{ToDo: A bit nicer}


\chapter{Evaluation}


\chapter{Future Work}
\section{Implementation of Further Improvements}
As shown before, we have implemented some improvement methods, but there are still more possible ways to make our PDR algorithm more efficient.

\subsection{Interpolation}
Ultimate already supports ways of computing an interpolant for two given formulas. The idea is, that everytime a query to the SMT-solver is unsatisfiable we, instead of adding the negated proof-obligation to the frames, add a calculated interpolant for the query. \par
Let $\ell$ and $\ell_{pre}$ be two locations where $\ell_{pre}$ is a predecessor of $\ell$, $F_{i - 1, \ell_{pre}}$ be a frame, $T_{\ell_{pre} \rightarrow \ell}$ be the transition from $\ell_{pre}$ to $\ell$, and $t'$ be a primed formula. \\
To get an interpolant $I$ for that query we first need to define $A$ and $B$, we do that by dividing the query the following way:
\begin{equation*}
\underbrace{F_{i - 1, \ell_{pre}} \land T_{\ell_{pre} \rightarrow \ell}}_{A} \land \underbrace{t'}_B
\end{equation*}
Because we have proven the query unsatisfiable generating an interpolant is possible. \\

\subsection{Procedures}
Ultimate aims to verify C programs, most of which contain procedure calls, which do not work with PDR yet because xyz


\pagebreak

\begin{thebibliography}{999}

\bibitem{Zitat00} Vizel Y., Gurfinkel A. (2014) Interpolating Property Directed Reachability. In: Biere A., Bloem R. (eds) Computer Aided Verification. CAV 2014. Lecture Notes in Computer Science, vol 8559. Springer, Cham

\bibitem{Zitat01} Bradley A.R. (2011) SAT-Based Model Checking without Unrolling. In: Jhala R., Schmidt D. (eds) Verification, Model Checking, and Abstract Interpretation. VMCAI 2011. Lecture Notes in Computer Science, vol 6538. Springer, Berlin, Heidelberg

\bibitem{cav} \url{https://fmv.jku.at/hwmcc10/results.html}

\bibitem{Zitat02} \textsc{Ultimate}: \url{https://ultimate.informatik.uni-freiburg.de}

\bibitem{Welp} Tobias Welp and Andreas Kuehlmann. 2013. QF BV model checking with property directed reachability. In Proceedings of the Conference on Design, Automation and Test in Europe (DATE '13). EDA Consortium, San Jose, CA, USA, 791-796.


\bibitem{Zitat03} N. Een, A. Mishchenko and R. Brayton, "Efficient implementation of property directed reachability," 2011 Formal Methods in Computer-Aided Design (FMCAD), Austin, TX, 2011, pp. 125-134.
Reachability"

\bibitem{Zitat04} Cimatti A., Griggio A. (2012) Software Model Checking via IC3. In: Madhusudan P., Seshia S.A. (eds) Computer Aided Verification. CAV 2012. Lecture Notes in Computer Science, vol 7358. Springer, Berlin, Heidelberg

\bibitem{GeneralizedIc3} Hoder K., BjÃ¸rner N. (2012) Generalized Property Directed Reachability. In: Cimatti A., Sebastiani R. (eds) Theory and Applications of Satisfiability Testing â SAT 2012. SAT 2012. Lecture Notes in Computer Science, vol 7317. Springer, Berlin, Heidelberg

\bibitem{Zitat05} T. Lange, M. R. Neuhauber and T. Noll, "IC3 software model checking on control flow automata," 2015 Formal Methods in Computer-Aided Design (FMCAD), Austin, TX, 2015, pp. 97-104.

\bibitem{Zitat06} Heizmann M., Hoenicke J., Podelski A. (2013) Software Model Checking for People Who Love Automata. In: Sharygina N., Veith H. (eds) Computer Aided Verification. CAV 2013. Lecture Notes in Computer Science, vol 8044. Springer, Berlin, Heidelberg

\bibitem{Zitat07} Thomas A. Henzinger, Ranjit Jhala, Rupak Majumdar, and GrÃ©goire Sutre. 2002. Lazy abstraction. In Proceedings of the 29th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL '02). ACM, New York, NY, USA, 58-70

\end{thebibliography}

\end{document}